---
description: 
globs: 
alwaysApply: false
---
# macOS Accessibility (`ax`) Binary Rules & Knowledge

This document outlines the functionality, build process, testing procedures, and technical details of the `ax` Swift command-line utility, designed for interacting with the macOS Accessibility framework.

## 1. `ax` Binary Overview

*   **Purpose**: Provides a JSON-based interface to query UI elements and perform actions using the macOS Accessibility API. It\'s intended to be called by other processes (like the MCP server).
*   **Communication**: Operates by reading JSON commands from `stdin` and writing JSON responses (or errors) to `stdout` (or `stderr` for errors).
*   **Core Commands**:
    *   `query`: Retrieves information about UI elements.
    *   `perform`: Executes an action on a UI element.
*   **Key Input Fields (JSON)**:
    *   `cmd` (string): "query" or "perform".
    *   `locator` (object): Specifies the target element(s).
        *   `app` (string): Bundle ID or localized name of the target application (e.g., "com.apple.TextEdit", "Safari").
        *   `role` (string): The accessibility role of the target element (e.g., "AXWindow", "AXButton", "*").
        *   `match` (object): Key-value pairs of attributes to match (e.g., `{"AXMain": "true"}`). Values are strings.
        *   `pathHint` (array of strings, optional): A path to navigate the UI tree (e.g., `["window[1]", "toolbar[1]"]`).
    *   `attributes` (array of strings, optional): For `query`, specific attributes to retrieve. Defaults to a common set if omitted.
    *   `action` (string, optional): For `perform`, the action to execute (e.g., "AXPress").
    *   `multi` (boolean, optional): For `query`, if `true`, returns all matching elements. Defaults to `false`.
    *   `requireAction` (string, optional): For `query` (passed from `CommandEnvelope`), filters results to elements supporting a specific action.
    *   `debug_logging` (boolean, optional): If `true`, includes detailed internal debug logs in the response.
    *   `max_elements` (integer, optional): For `query` with `multi: true`, limits the number of elements for which full attributes are fetched to manage performance.
    *   `output_format` (enum: 'smart' | 'verbose' | 'text_content', optional, default: 'smart'): Controls attribute verbosity and format.
        *   `smart`: (Default) Omits empty/placeholder values. Key-value pairs.
        *   `verbose`: Includes all attributes, even empty/placeholders. Key-value pairs.
        *   `text_content`: Returns only concatenated text values of common textual attributes. No keys. Ignores `attributes_to_query`.
*   **Key Output Fields (JSON)**:
    *   Success (`query` with `output_format: 'smart'` or `'verbose'`): `{ "attributes": { "AXTitle": "...", ... } }`
    *   Success (`query`, `multi: true` with `output_format: 'smart'` or `'verbose'`): `{ "elements": [ { "AXTitle": "..." }, ... ] }`
    *   Success (`query` with `output_format: 'text_content'`): `{ "text_content": "extracted text..." }`
    *   Success (`perform`): `{ "status": "ok" }`
    *   Error: `{ "error": "Error message description" }`
    *   `debug_logs` (array of strings, optional): Included in success or error responses if `debug_logging` was true in the input.

## 2. Functionality - How it Works

The `ax` binary is implemented in Swift in `ax/Sources/AXHelper/main.swift`. (Current version: `AX_BINARY_VERSION = "1.1.0"`)

*   **Application Targeting**:
    *   `getApplicationElement(bundleIdOrName: String)`: (As originally described) Finds `NSRunningApplication` by bundle ID then localized name, then uses `AXUIElementCreateApplication(pid)`.

*   **Element Location**:
    *   **`search(element:locator:requireAction:depth:maxDepth:)`**:
        *   Used for single-element queries (`multi: false`).
        *   Performs a depth-first search.
        *   Matches `AXRole` against `locator.role` and attributes in `locator.match`.
            *   **Boolean attributes** (e.g., `AXMain`): Robustly handles direct `CFBooleanRef` and booleans wrapped in `AXValue` (by checking `AXValueGetType` raw value `4` for `kAXValueBooleanType` and using `AXValueGetValue`). Compares against input strings "true" or "false".
        *   If `requireAction` (passed from `CommandEnvelope`) is specified, it filters the element if it doesn\'t support the action (checked via `kAXActionNamesAttribute`).
        *   **Enhanced Child Discovery**: To find deeply nested elements (especially within web views or complex containers), it now probes for children not just via `kAXChildrenAttribute`, but also using a `webAttributesListForCollectAll` (e.g., "AXDOMChildren", "AXContents") if the current element\'s role is in `webContainerRoles` (which now includes "AXWebArea", "AXWebView", "BrowserAccessibilityCocoa", "AXScrollArea", "AXGroup", "AXWindow", "AXSplitGroup", "AXLayoutArea").
    *   **`collectAll(appElement:locator:currentElement:depth:maxDepth:currentPath:elementsBeingProcessed:foundElements:)`**:
        *   Used for multi-element queries (`multi: true`).
        *   Recursively traverses, matching `locator.role` (supports `"*"` wildcard) and `locator.match` with robust boolean handling similar to `search`.
        *   **Child Discovery**: Uses `kAXChildrenAttribute` and the same extended `webAttributesListForCollectAll` (like in `search`) if the element role is a known container (e.g., `AXWebArea`, `AXWindow`, `AXGroup`, etc.).
        *   **Deduplication**: Uses `AXUIElementHashableWrapper` and an `elementsBeingProcessed` set to avoid cycles and redundant work.
        *   Limited by `MAX_COLLECT_ALL_HITS` (e.g., 100000) and a recursion depth limit.
    *   **`navigateToElement(from:pathHint:)`**: (As originally described) Parses path hints like "window[1]" to navigate the tree.

*   **Attribute Retrieval**:
    *   `getElementAttributes(element:requestedAttributes:forMultiDefault:targetRole:)`:
        *   Fetches attributes based on `requestedAttributes` or discovers all if empty (for `smart`/`verbose` formats).
        *   Converts `CFTypeRef` to Swift/JSON, including specific handling for `AXValue` (CGPoint, CGSize, booleans).
        *   **Output Formatting (`output_format` parameter)**:
            *   `smart` (default): Omits attributes with empty string values or "Not available".
            *   `verbose`: Includes all attributes, even if empty or "Not available".
            *   `text_content`: This mode bypasses `getElementAttributes` for the final response structure. Instead, `handleQuery` calls a new `extractTextContent` function.
        *   Includes `ComputedName` and `IsClickable` for `smart`/`verbose` formats.

*   **Text Extraction (`extractTextContent` for `output_format: 'text_content'`)**:
    *   Called by `handleQuery` when `output_format` is `text_content`.
    *   Ignores `attributes_to_query` from the input.
    *   Fetches a predefined list of text-bearing attributes (e.g., "AXValue", "AXTitle", "AXDescription", "AXHelp", "AXPlaceholderValue", "AXLabelValue", "AXRoleDescription").
    *   Extracts and concatenates their non-empty string values, separated by newlines.
    *   If `multi: true`, concatenates text from all found elements, separated by double newlines.
    *   Returns a simple JSON response: `{"text_content": "all extracted text..."}`.

*   **Action Performing**: (As originally described, uses `elementSupportsAction` and `AXUIElementPerformAction`).

*   **Error Handling**: (As originally described, `ErrorResponse` JSON to `stderr`).

*   **Debugging**:
    *   `GLOBAL_DEBUG_ENABLED` (Swift constant, `true`): If true, all `debug()` messages are printed *live* to `stderr` of the `ax` process.
    *   `debug_logging: true` (input JSON field): Enables `commandSpecificDebugLoggingEnabled`.
    *   `collectedDebugLogs` (Swift array): Stores debug messages if `commandSpecificDebugLoggingEnabled` is true. This array is included in the `debug_logs` field of the final JSON response (on `stdout` for success, or `stderr` for `ErrorResponse`).
    *   `AX_BINARY_VERSION` constant is included in debug logs.

*   **Concurrency**: Functions interacting with AppKit/Accessibility or calling `debug()` are annotated with `@MainActor`. Global variables for debug state are accessed from main-thread contexts.

## 3. Build Process & Optimization

The `ax` binary is built using the `Makefile` located in the `ax/` directory.

*   **Makefile (`ax/Makefile`)**:
    *   **Universal Binary**: Builds for both `arm64` and `x86_64`.
    *   **Cleaning**: The `all` target now first runs `rm -f ax/ax` and `swift package clean` to ensure a fresh build and help catch all compilation errors.
    *   **Optimization Flags**:
        *   `-Xswiftc -Osize`: Swift compiler optimizes for binary size.
        *   `-Xlinker -dead_strip`: Linker performs dead code elimination (Note: `-Wl,-dead_strip` caused issues when specifying architecture, so `-Wl,` was removed).
    *   **Symbol Stripping**:
        *   `strip -x $(UNIVERSAL_BINARY_PATH)`: Aggressively removes symbols.
    *   **Output**: `ax/ax`.
*   **Optimization Journey Summary**:
    *   The combination of `-Xswiftc -Osize`, `-Xlinker -dead_strip`, and `strip -x` is effective.
    *   Link-Time Optimization (LTO) (`-Xswiftc -lto=llvm-full`) resulted in linker errors.
    *   UPX compression created malformed, unusable binaries.

## 4. Running & Testing

(Largely as originally described)

*   **Runner Script (`ax/ax_runner.sh`)**: Recommended for manual execution.
*   **Manual Testing Workflow**:
    1.  Verify target application state.
    2.  Construct JSON input.
    3.  Execute: `echo \'...\' | ./ax/ax_runner.sh`
    4.  Interpret Output:
        *   `stdout`: Primary JSON response.
        *   `stderr`: Contains `ErrorResponse` JSON if `ax` itself errors. Also, if `GLOBAL_DEBUG_ENABLED` is true (default), `stderr` will *additionally* show a live stream of `DEBUG:` messages from the `ax` binary\'s operations, separate from the `debug_logs` array in the final JSON.
*   **Example Test Queries (with `debug_logging` and `max_elements`)**:
    1.  **Find TextEdit\'s main window**:
        ```bash
        echo \'{"cmd":"query","locator":{"app":"com.apple.TextEdit","role":"AXWindow","match":{"AXMain":"true"}},"return_all_matches":false,"debug_logging":true}\' | ./ax/ax_runner.sh
        ```
    2.  **List all text elements in TextEdit (potentially many, so `max_elements` is useful)**:
        ```bash
        echo \'{"cmd":"query","locator":{"app":"com.apple.TextEdit","role":"AXStaticText","match":{}},"return_all_matches":true,"max_elements":50,"debug_logging":true}\' | ./ax/ax_runner.sh
        ```
*   **Permissions**: (As originally described - crucial for the parent process).

## 5. macOS Accessibility (AX) Intricacies & Swift Integration

(Largely as originally described, but with emphasis on boolean handling)

*   **`AXValue` for Booleans**: When an attribute like `AXMain` is an `AXValueRef` (e.g., `<AXValue ... {value = true}>`), it\'s not a direct `CFBooleanRef`. Code must:
    1.  Check `CFGetTypeID(value)` against `AXValueGetTypeID()`.
    2.  Use `AXValueGetType(axValueRef)` and compare its `rawValue` to `4` (which corresponds to `kAXValueBooleanType`, as the constant itself might not be available or compile).
    3.  Use `AXValueGetValue(axValueRef, valueType, &boolResult)` to extract the `DarwinBoolean`.
*   **Constants**: Key constants like `kAXActionNamesAttribute` are defined as Swift strings ("AXActionNames") if not directly available from frameworks.

This document should serve as a good reference for understanding and working with the `ax` binary.
